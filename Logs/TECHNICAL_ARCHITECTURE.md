# Technical Architecture - TJ's Bake & Browse

## System Architecture Overview

### High-Level Architecture

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Frontend      │    │   Next.js API   │    │   Supabase      │
│   (React/TS)    │◄──►│   Routes        │◄──►│   (PostgreSQL)  │
│                 │    │                 │    │                 │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   NextAuth.js   │    │   Middleware    │    │   File Storage  │
│   (JWT Auth)    │    │   (Route Guard) │    │   (Supabase)    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

## Frontend Architecture

### Component Structure

```
components/
├── AllergenIcons.tsx      # Allergen display component
├── DateTimePicker.tsx     # Date/time selection component
├── DebugBasket.tsx        # Development basket debugger
├── Footer.tsx             # Site footer
├── NavAuth.tsx            # Authentication navigation
├── NavBasket.tsx          # Basket navigation
├── ProductCard.tsx        # Individual product display
└── ProductGrid.tsx        # Product listing grid
```

### Page Structure (App Router)

```
app/
├── layout.tsx             # Root layout with providers
├── page.tsx               # Homepage
├── about/page.tsx         # About us page
├── baked-goods/page.tsx   # Baked goods category
├── groceries/page.tsx     # Groceries category
├── basket/page.tsx        # Shopping basket
├── checkout/page.tsx      # Order checkout
├── login/page.tsx         # User login
├── register/page.tsx      # User registration
├── order-success/page.tsx # Order confirmation
└── admin/                 # Admin dashboard
    ├── layout.tsx         # Admin layout
    ├── page.tsx           # Admin overview
    ├── products/page.tsx  # Product management
    ├── inventory/page.tsx # Inventory management
    ├── orders/page.tsx    # Order management
    └── categories/page.tsx # Category management
```

### State Management

- **Local State**: React hooks for component-level state
- **Session State**: NextAuth.js for user authentication
- **Basket State**: localStorage with cross-tab synchronization
- **Form State**: Controlled components with validation

## Backend Architecture

### API Route Structure

```
app/api/
├── auth/
│   ├── [...nextauth]/route.ts    # NextAuth.js configuration
│   └── register/route.ts         # User registration
├── admin/
│   ├── categories/route.ts       # Category CRUD operations
│   ├── inventory/
│   │   ├── route.ts              # Inventory management
│   │   ├── export/route.ts       # CSV export
│   │   └── import/route.ts       # CSV import
│   ├── orders/route.ts           # Order management
│   └── products/route.ts         # Product CRUD operations
├── availability/route.ts          # Product availability
├── cart/route.ts                 # Basket operations
├── orders/route.ts               # Order placement
├── products/route.ts             # Product catalogue
└── slots/route.ts                # Time slot management
```

### Database Schema

#### Core Tables

```sql
-- Users table with role-based access
CREATE TABLE public.users (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  email text UNIQUE NOT NULL,
  password_hash text NOT NULL,
  name text NOT NULL,
  mobile text NOT NULL,
  role text NOT NULL DEFAULT 'customer' CHECK (role IN ('customer','staff','admin')),
  marketing_opt_in boolean DEFAULT false,
  created_at timestamptz DEFAULT now()
);

-- Products with category relationships
CREATE TABLE public.products (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name text NOT NULL,
  sku text UNIQUE NOT NULL,
  short_description text,
  description text,
  price_pence integer NOT NULL CHECK (price_pence >= 0),
  pack_label text,
  allergens text[] DEFAULT '{}',
  ingredients text,
  image_url text,
  stock int NOT NULL DEFAULT 0,
  visible boolean NOT NULL DEFAULT true,
  category_id uuid REFERENCES public.categories(id),
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Categories for product organisation
CREATE TABLE public.categories (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name text UNIQUE NOT NULL,
  slug text UNIQUE NOT NULL,
  description text,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Orders with customer details
CREATE TABLE public.orders (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  order_number bigint GENERATED BY DEFAULT AS IDENTITY UNIQUE,
  user_id uuid REFERENCES public.users(id) ON DELETE SET NULL,
  status text NOT NULL DEFAULT 'unpaid' CHECK (status IN ('unpaid','preparing','ready','collected','cancelled')),
  pickup_date date NOT NULL,
  pickup_time time NOT NULL,
  subtotal_pence integer NOT NULL,
  total_pence integer NOT NULL,
  bag boolean DEFAULT false,
  customer_name text NOT NULL,
  customer_email text NOT NULL,
  customer_phone text,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Order items for individual products
CREATE TABLE public.order_items (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  order_id uuid REFERENCES public.orders(id) ON DELETE CASCADE,
  product_id uuid REFERENCES public.products(id) ON DELETE SET NULL,
  name text NOT NULL,
  price_pence integer NOT NULL,
  quantity integer NOT NULL,
  created_at timestamptz DEFAULT now()
);
```

#### Indexes for Performance

```sql
-- Performance indexes
CREATE INDEX IF NOT EXISTS products_visible_stock_idx ON public.products (visible, stock);
CREATE INDEX IF NOT EXISTS orders_pickup_status_idx ON public.orders (pickup_date, status);
CREATE INDEX IF NOT EXISTS idx_orders_pickup_date_time ON public.orders (pickup_date, pickup_time);
CREATE INDEX IF NOT EXISTS idx_products_category_visible ON public.products (category_id, visible);
CREATE INDEX IF NOT EXISTS idx_users_email ON public.users (email);
```

### Row Level Security (RLS) Policies

#### Products Table

```sql
-- Public read access for visible products
CREATE POLICY catalogue_read ON public.products
FOR SELECT USING (visible = true AND stock > 0);

-- Admin full access
CREATE POLICY admin_full_access ON public.products
FOR ALL USING (
  EXISTS (
    SELECT 1 FROM public.users
    WHERE users.id = auth.uid()
    AND users.role = 'admin'
  )
);
```

#### Orders Table

```sql
-- Users can only see their own orders
CREATE POLICY user_orders ON public.orders
FOR SELECT USING (
  user_id = auth.uid() OR
  EXISTS (
    SELECT 1 FROM public.users
    WHERE users.id = auth.uid()
    AND users.role IN ('admin', 'staff')
  )
);

-- Admin can update order status
CREATE POLICY admin_update_orders ON public.orders
FOR UPDATE USING (
  EXISTS (
    SELECT 1 FROM public.users
    WHERE users.id = auth.uid()
    AND users.role = 'admin'
  )
);
```

## Authentication & Authorization

### NextAuth.js Configuration

```typescript
export const authOptions: NextAuthOptions = {
	session: {
		strategy: "jwt",
		maxAge: 30 * 24 * 60 * 60, // 30 days
	},
	providers: [
		Credentials({
			name: "Email & Password",
			credentials: {
				email: { label: "Email" },
				password: { label: "Password", type: "password" },
			},
			async authorize(creds) {
				// Validation and authentication logic
			},
		}),
	],
	callbacks: {
		async jwt({ token, user }) {
			// JWT token enhancement
		},
		async session({ session, token }) {
			// Session enhancement
		},
	},
};
```

### Middleware Security

```typescript
// middleware.ts - Route protection
export async function middleware(req: NextRequest) {
	const { pathname } = req.nextUrl;

	// Admin route protection
	if (pathname.startsWith("/admin")) {
		const token = await getToken({ req, secret: process.env.NEXTAUTH_SECRET });
		if (!token || !isAdminFromToken(token)) {
			return NextResponse.redirect(new URL("/", req.url));
		}
	}

	// API protection
	if (pathname.startsWith("/api/admin/")) {
		const token = await getToken({ req, secret: process.env.NEXTAUTH_SECRET });
		if (!token || !isAdminFromToken(token)) {
			return NextResponse.json({ error: "Unauthorised" }, { status: 401 });
		}
	}
}
```

## Data Flow & Business Logic

### Order Processing Flow

```
1. Customer adds items to basket (localStorage)
2. Customer proceeds to checkout
3. System validates pickup time availability
4. Order created with status 'unpaid'
5. Payment processing (future enhancement)
6. Order status updated to 'paid'
7. Admin processes order
8. Order status: preparing → ready → collected
```

### Time Slot Management

```typescript
// lib/slots.ts - Time slot generation
export function generateSlots(
  now: Date,
  days = 7,
  open = "09:00",
  close = "17:00",
  stepMinutes = 30
): GeneratedDay[] {
  // Business logic for slot generation
  // - Skip Sundays
  - Same-day cutoff at 12:00
  - 30-minute intervals
  - Capacity checking
}
```

### Inventory Management

```typescript
// Atomic order placement with stock validation
export async function placeOrderAtomic(
	user_id: uuid,
	items: jsonb,
	bag_opt_in: boolean,
	pickup_date: date,
	pickup_time: time
): Promise<uuid> {
	// Transaction-based order creation
	// Stock validation and updates
	// Order and order_items creation
}
```

## Security Implementation

### Input Validation

```typescript
// Zod schemas for API validation
const orderSchema = z.object({
	items: z.array(
		z.object({
			product_id: z.string().uuid(),
			name: z.string().min(1),
			price_pence: z.number().positive(),
			qty: z.number().positive(),
		})
	),
	pickup_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
	pickup_time: z.string().regex(/^\d{2}:\d{2}$/),
	customer_name: z.string().min(1),
	customer_email: z.string().email(),
});
```

### SQL Injection Prevention

- **Parameterized queries** via Supabase client
- **Input sanitization** with Zod validation
- **RLS policies** for data access control
- **Prepared statements** for complex queries

### CSRF Protection

- **Next.js built-in CSRF protection**
- **SameSite cookie attributes**
- **Token-based form submission** (future enhancement)

## Performance Optimisation

### Frontend Optimisations

```typescript
// next.config.mjs
const nextConfig = {
	reactStrictMode: true,
	swcMinify: true,
	compress: true,
	poweredByHeader: false,
	generateEtags: false,
	images: {
		domains: ["yourdomain.com"],
		formats: ["image/webp", "image/avif"],
	},
};
```

### Database Optimisations

- **Strategic indexing** on frequently queried fields
- **Query optimisation** with proper joins
- **Connection pooling** via Supabase
- **Result caching** for static data

### API Optimisations

- **Response compression** with gzip
- **Efficient data fetching** with selective queries
- **Pagination** for large datasets
- **Caching headers** for static content

## Error Handling & Logging

### Structured Logging

```typescript
// lib/logger.ts
export const logger = {
	info: (message: string, meta?: any) => {
		console.log(
			JSON.stringify({
				level: "info",
				message,
				meta,
				timestamp: new Date().toISOString(),
			})
		);
	},
	error: (message: string, error?: any, meta?: any) => {
		console.error(
			JSON.stringify({
				level: "error",
				message,
				error: error?.message,
				stack: error?.stack,
				meta,
				timestamp: new Date().toISOString(),
			})
		);
	},
};
```

### Error Boundaries

```typescript
// Error handling in API routes
try {
	const result = await processOrder(data);
	return NextResponse.json(result);
} catch (error) {
	logger.error("Order processing failed", error, { orderData: data });
	return NextResponse.json(
		{ error: "Order processing failed" },
		{ status: 500 }
	);
}
```

## Testing Strategy

### Unit Testing

```typescript
// Vitest configuration
import { defineConfig } from "vitest/config";

export default defineConfig({
	test: {
		environment: "happy-dom",
		setupFiles: ["./tests/setup.ts"],
		coverage: {
			provider: "v8",
			reporter: ["text", "json", "html"],
		},
	},
});
```

### Test Categories

1. **Unit tests**: Individual functions and components
2. **Integration tests**: API endpoint testing
3. **E2E tests**: Complete user journey testing
4. **Security tests**: Authentication and authorization
5. **Performance tests**: Load and stress testing

## Deployment & Infrastructure

### Environment Configuration

```bash
# Production environment variables
NEXTAUTH_SECRET=your-secure-secret
NEXTAUTH_URL=https://yourdomain.com
NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
SUPABASE_SERVICE_ROLE=your-service-role-key
NEXT_PUBLIC_ADMIN_EMAILS=admin@yourdomain.com
NEXT_PUBLIC_SLOT_CAPACITY=5
```

### Build Process

```bash
# Production build
npm run build
npm run start

# Or for static export
npm run export
```

### Hosting Options

1. **Vercel**: Optimized for Next.js
2. **Netlify**: Static site hosting
3. **AWS**: Full control and scalability
4. **Self-hosted**: Complete control

## Monitoring & Observability

### Health Checks

```typescript
// app/api/health/route.ts
export async function GET() {
	try {
		// Database connectivity check
		const { data, error } = await admin
			.from("products")
			.select("count")
			.limit(1);
		if (error) throw error;

		return NextResponse.json({
			status: "healthy",
			timestamp: new Date().toISOString(),
			database: "connected",
			uptime: process.uptime(),
		});
	} catch (error) {
		return NextResponse.json(
			{
				status: "unhealthy",
				timestamp: new Date().toISOString(),
				error: error.message,
			},
			{ status: 500 }
		);
	}
}
```

### Metrics Collection

- **Application performance** monitoring
- **Database query** performance
- **User interaction** tracking
- **Business metrics** collection

## Future Enhancements

### Technical Improvements

1. **GraphQL API** for flexible data fetching
2. **Real-time updates** with WebSockets
3. **Service worker** for offline functionality
4. **Progressive Web App** features

### Business Features

1. **Multi-location** support
2. **Advanced inventory** management
3. **Customer loyalty** programme
4. **Marketing automation** tools

---

_This technical architecture document provides the foundation for development decisions and system design. It should be updated as the system evolves and new requirements emerge._
